#!/bin/bash
# =============================================================================
# ABS
# (c) 2017, Petr Kulhanek, kulhanek@chemi.muni.cz
# (c) 2012, Petr Kulhanek, kulhanek@chemi.muni.cz
# (c) 2008-2009, Petr Kulhanek, kulhanek@chemi.muni.cz
# Charon Extension Layer v0.9
# (c) 2006, Petr Kulhanek, kulhanek@chemi.muni.cz
# Charon Extension Layer v0.8
# (c) 2005, Petr Kulhanek, kulhanek@chemi.muni.cz
# based on LCC module v1 - v5
# (c) 2001-2004, Petr Kulhanek, kulhanek@chemi.muni.cz
# =============================================================================

# ------------------------------------------------------------------------------

echo ""
echo "# ------------------------------------------------------------------------------"
echo "# L2.0: Cross-host user group translation rules for rsync ..."
echo "# ------------------------------------------------------------------------------"
echo ""
echo "Legend: I - input machine; S - storage machine; L - local input directory; W - working directory"
echo "        FST - file system type"
echo ""

# workdir group
INF_W_GROUP=`id -g -n`

# I->W and W->I
if [ -n "$INF_STORAGE_MACHINE_REALM_FOR_INPUT_MACHINE" ]; then
    INF_IW_RSYNCOPTS="--chown=:$INF_W_GROUP"
    INF_WI_RSYNCOPTS="--chown=:$INF_USTORAGEGROUP@$INF_STORAGE_MACHINE_REALM_FOR_INPUT_MACHINE"
else
    INF_IW_RSYNCOPTS="--chown=:$INF_W_GROUP"
    INF_WI_RSYNCOPTS="--chown=:$INF_USTORAGEGROUP"
fi

# S->W and W->S
INF_SW_RSYNCOPTS="--chown=:$INF_W_GROUP"
INF_WS_RSYNCOPTS="--chown=:$INF_USTORAGEGROUP"

# L->W and W->L
if [ "$INF_LOCAL_INPUT_DATA" == "YES" ]; then
    INF_LR=`stat "$INF_INPUT_DIR" --format=%G | tr '@' ' ' | awk '{ printf("%s",$2);}'`
    if [ -n "$INF_LR" ]; then
        if [ "$INF_LR" != "$INF_STORAGE_MACHINE_REALM" ]; then
            echo "" >&2
            echo " >>> ERROR: The local input directory realm '$INF_LR' does not match the storage machine realm '$INF_STORAGE_MACHINE_REALM'!" >&2
            echo "" >&2
            exit 1
        fi
        INF_LW_RSYNCOPTS="--chown=:$INF_W_GROUP"
        INF_WL_RSYNCOPTS="--chown=:$INF_USTORAGEGROUP@$INF_STORAGE_MACHINE_REALM"
    else
        INF_LW_RSYNCOPTS="--chown=:$INF_W_GROUP"
        INF_WL_RSYNCOPTS="--chown=:$INF_USTORAGEGROUP"
    fi
fi

export INF_IW_RSYNCOPTS
export INF_WI_RSYNCOPTS
export INF_SW_RSYNCOPTS
export INF_WS_RSYNCOPTS
export INF_LW_RSYNCOPTS
export INF_WL_RSYNCOPTS

echo "I->W : $INF_IW_RSYNCOPTS"
echo "W->I : $INF_WI_RSYNCOPTS"
echo "S->W : $INF_SW_RSYNCOPTS"
echo "W->S : $INF_WS_RSYNCOPTS"
echo "L->W : $INF_LW_RSYNCOPTS"
echo "W->L : $INF_WL_RSYNCOPTS"

INF_L_FSTYPE="n.a."
if [ "$INF_LOCAL_INPUT_DATA" == "YES" ]; then
    # %m does not work in IT4I
    # INF_L_MP=`stat "$INF_INPUT_DIR" --format="%m"`

    # is local input directory of nfs4:krb5 type?
    INF_L_DEV=`stat "$INF_INPUT_DIR" --format="%d"`
    INF_L_DEV_MAJ=$(($INF_L_DEV / 256))
    INF_L_DEV_MIN=$(($INF_L_DEV % 256))

    if [ -n "`grep \"$INF_L_DEV_MAJ:$INF_L_DEV_MIN\" /proc/self/mountinfo | grep 'sec=krb5'`" ]; then
        INF_L_FSTYPE="nfs4:krb5"
    else
        INF_L_FSTYPE=`grep "$INF_L_DEV_MAJ:$INF_L_DEV_MIN" /proc/self/mountinfo | awk '{ print $8; }'`
    fi
    unset INF_L_DEV INF_L_DEV_MAJ INF_L_DEV_MIN
fi
export INF_L_FSTYPE
echo "L FST: $INF_L_FSTYPE"

INF_INPUT_MACHINE_ENABLED_FOR_DATA_NOTICE=""
if [ "$INF_INPUT_MACHINE" != "$INF_STORAGE_MACHINE" ]; then
    INF_INPUT_MACHINE_ENABLED_FOR_DATA="YES"
else
    INF_INPUT_MACHINE_ENABLED_FOR_DATA="NO"
    INF_INPUT_MACHINE_ENABLED_FOR_DATA_NOTICE="(input machine is the same as the storage machine)"
fi
INF_INPUT_MACHINE_ENABLED_FOR_EXEC=YES
if [ "$INF_BATCH_SERVER_GROUPNS" != "personal" ]; then
    if [ "$INF_INPUT_MACHINE_GROUPNS" == "personal" ]; then
        # if the job is sent outside of personal machine then we cannot expect
        # that the personal machine will be still on at the end of job and thus available for data transfer
        INF_INPUT_MACHINE_ENABLED_FOR_DATA="NO"
        INF_INPUT_MACHINE_ENABLED_FOR_EXEC="NO"
        INF_INPUT_MACHINE_ENABLED_FOR_DATA_NOTICE="(input machine is in a personal site)"
    fi
fi
export INF_INPUT_MACHINE_ENABLED_FOR_DATA
echo "Input machine enabled for data: $INF_INPUT_MACHINE_ENABLED_FOR_DATA $INF_INPUT_MACHINE_ENABLED_FOR_DATA_NOTICE"
export INF_INPUT_MACHINE_ENABLED_FOR_EXEC
echo "Input machine enabled for exec: $INF_INPUT_MACHINE_ENABLED_FOR_EXEC"

unset INF_INPUT_MACHINE_ENABLED_FOR_DATA_NOTICE

# INF_SURROGATE_MACHINES is set in abs-restore-env

if [ -z "$INF_SURROGATE_MACHINES" ]; then
echo "Surrogate machines for exec   : -none-"
else
echo "Surrogate machines for exec   : $INF_SURROGATE_MACHINES"
fi

echo ""
echo "# ------------------------------------------------------------------------------"
echo "# L2.1: Prepare the working directory ..."
echo "# ------------------------------------------------------------------------------"
echo ""
export INF_MAIN_NODE=`hostname -f`
echo "# Job ID             : $INF_JOB_ID"
echo "# Main working node  : $INF_MAIN_NODE"
echo "# Work directory type: $INF_WORK_DIR_TYPE"
echo "# Data IN copy mode  : $INF_DATAIN"

# ------------------------------------------------------------------------------
# set working directory

INF_WORK_DIR="`$ABS_ROOT/sbin/abs-get-work-dir --type main $INF_WORK_DIR_TYPE`"
if [ $? -ne -0 ]; then
    return 1
fi
echo "# Working directory  : $INF_WORK_DIR"
INF_WORK_DIR="`eval echo "$INF_WORK_DIR"`"
echo "# Working directory  : $INF_WORK_DIR"

# ------------------------------------------------------------------------------
# create working directories if necessary
echo ""
case $INF_DATAIN in
    keep)
        echo ">>> $INF_MAIN_NODE:$INF_WORK_DIR ---"
        timeout 30 df -h
        if [ $? -ne 0 ]; then
            echo ">>> WARNING: the df command was not completed due to an error or timeout."
        fi
    ;;
    copy)
        echo "# Creating working directories on the working nodes ..."
        for NODE_NAME in `cat $PBS_NODEFILE | sort -u`; do
            echo ""
            echo ">>> $NODE_NAME:$INF_WORK_DIR ---"
            ssh -x "$INF_SSH_OPTIONS" $NODE_NAME "umask $INF_UMASK; if ! [ -d \"$INF_WORK_DIR\" ]; then mkdir -p \"$INF_WORK_DIR\"; fi; EXIT_CODE=\$?; if [ -n \"$INF_UBATCHGROUP\" ]; then chgrp \"$INF_BATCHGROUP\" \"$INF_WORK_DIR\"; fi; timeout 30 df -h; if [ \$? -ne 0 ]; then echo \">>> WARNING: the df command was not completed due to an error or timeout.\"; fi; exit \$EXIT_CODE;"

            if [ $? -ne 0 ]; then
                echo "" >&2
                echo " >>> ERROR: Unable to create the working directory on the specified node!" >&2
                echo "" >&2
                exit 1
            fi
        done
    ;;
esac

export INF_WORK_DIR

# ------------------------------------------------------------------------------
# go to working directory
echo ""
echo "# Changing the current directory to the working directory ..."
cd "$INF_WORK_DIR"

if [ $? -ne 0 ]; then
    echo "" >&2
    echo " >>> ERROR: Unable to change the current directory to the working directory." >&2
    echo "" >&2
    exit 1
fi

# ------------------------------------------------------------------------------
# move info file to working directory

mv "$TMPDIR/${_TNAME_}.info" "$INF_WORK_DIR/${INF_WHOLE_NAME}.info"
if [ $? -ne 0 ]; then
    echo "" >&2
    echo " >>> ERROR: Unable to move the job info file into the working directory!" >&2
    echo "" >&2
    exit 1
fi

echo ""
echo "# ------------------------------------------------------------------------------"
echo "# L2.2: Resources files ..."
echo "# ------------------------------------------------------------------------------"

echo ""
echo "# PBS_NODEFILE ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
echo "# File: $PBS_NODEFILE"

if ! [ -f "$PBS_NODEFILE" ]; then
    echo ""  >&2
    echo " >>> ERROR: PBS_NODEFILE does not exist!"  >&2
    echo "" >&2
    exit 1
fi

cat "$PBS_NODEFILE"

# create copy of node file
export INF_NODEFILE="$INF_WORK_DIR/${INF_WHOLE_NAME}.nodes"
cat "$PBS_NODEFILE"  > "$INF_NODEFILE"
if [ $? -ne 0 ]; then exit 1; fi

# ------------------------------------------------------------------------------

echo ""
echo "# INF_MPIFILE ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
export INF_MPIFILE="$INF_WORK_DIR/${INF_WHOLE_NAME}.mpinodes"
rm -f "$INF_MPIFILE"
export HOSTNAME=`hostname -f`

for NODE in $HOSTNAME `cat "$INF_NODEFILE" | sort -u | grep -v "$HOSTNAME"`; do
    NCPUS="`cat $INF_NODEFILE | grep $NODE | wc -l`"
    echo "$NODE slots=$NCPUS" >> "$INF_MPIFILE"
    if [ $? -ne 0 ]; then exit 1; fi
done 

echo "# File: $INF_MPIFILE"
cat "$INF_MPIFILE"
if [ $? -ne 0 ]; then exit 1; fi

# ------------------------------------------------------------------------------

if [ "$INF_NGPUS" -gt 0 ]; then
    echo ""
    export INF_GPUFILE="$INF_WORK_DIR/${INF_WHOLE_NAME}.gpus"
    rm -f "$INF_GPUFILE"
    cat $INF_MPIFILE | while read NODE MPISPEC; do
        (
            # the is quite complicated but both pbsdsh and pbs_tmrsh write output directly to output and error files
            # and not to the standard and error outputs
            echo "# Scanning GPU node : $NODE"
            pbs_tmrsh $NODE sh -c "echo \$(hostname -f) gpus=\$CUDA_VISIBLE_DEVICES | ssh $HOSTNAME \"cat >> $INF_GPUFILE\""
            if [ $? -ne 0 ]; then exit 1; fi
         ) < /dev/null
    done 
    echo "# INF_GPUFILE ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    echo "# File: $INF_GPUFILE"
    cat "$INF_GPUFILE"
    if [ $? -ne 0 ]; then exit 1; fi
fi

# ------------------------------------------------------------------------------
# update info file

echo ""
echo "# Write the job start and update the info file in the input directory ..."

$ABS_ROOT/sbin/abs-update-infofile start
if [ $? -ne 0 ]; then
    echo "" >&2
    echo " >>> ERROR: Unable to update job status in the job info file!" >&2
    echo "" >&2
    exit 1
fi

case $INF_DATAIN in
    keep)
        echo " > already updated in the keep datain mode ..."
    ;;
    copy)
        inf-retry-cmd inf-copy-to-inputdir "$INF_WORK_DIR/${INF_WHOLE_NAME}.info" "${INF_WHOLE_NAME}.info"
        if [ $? -ne 0 ]; then exit 1; fi
    ;;
esac


echo ""
echo "# ------------------------------------------------------------------------------"
echo "# L2.3: Current node utilizations ..."
echo "# ------------------------------------------------------------------------------"

for NODE_NAME in `cat $INF_NODEFILE | sort -u`; do
    echo ""
    echo ">>> $NODE_NAME ----------------------------------"
    ssh -x "$INF_SSH_OPTIONS" $NODE_NAME "top -b -n 1 | awk '{ if( start == 0 ) print \$0; else if( (\$9 > 1) || (\$10 > 1) ) print \$0; } /PID USER/ { start = 1; }'"
done

echo ""
echo "# ------------------------------------------------------------------------------"
echo "# L2.4: Machine hardware info ..."
echo "# ------------------------------------------------------------------------------"

echo
echo "# CPU info"
echo "# ============================================================================="
type lscpu &> /dev/null

if [ $? -eq 0 ]; then
    lscpu
else
    echo ">>> INFO: the lscpu command not available ... skipping"
fi

if [ $INF_NGPUS -gt 0 ]; then
    echo ""
    echo "# GPU info"
    echo "# ============================================================================="
    echo "# CUDA_VISIBLE_DEVICES = $CUDA_VISIBLE_DEVICES"
    type nvidia-smi &> /dev/null
    if [ $? -eq 0 ]; then
        nvidia-smi
    fi
fi

echo ""
echo "# ------------------------------------------------------------------------------"
echo "# L2.5: Current NUMA settings on the master node ..."
echo "# ------------------------------------------------------------------------------"

type numactl &> /dev/null

if [ $? -eq 0 ]; then
    numactl --show
else
    echo ">>> INFO: the numactl command not available ... skipping"
fi

echo ""
echo "# ------------------------------------------------------------------------------"
echo "# L2.6: Determining type of executive environment ..."
echo "#       Supported types: raw, cpuset, exclusive"
echo "# ------------------------------------------------------------------------------"

#determine INF_EXEC_TYPE -------------------------------------------------------

TMP_FILE=/tmp/$USER.$$.pbsnodes
# this does not work in IT4I as the node file contains full node names
# pbsnodes `cat $INF_NODEFILE | sort -u` > $TMP_FILE
pbsnodes `pqstat -j 1361611 | grep exec_host | awk '{ print $3;}' | tr '+' '\n' | cut -f 1 -d '/' | sort -u` > $TMP_FILE
INF_MAX_NCPUS=`awk 'BEGIN { ncpus = 0; } /resources_available.ncpus/ { ncpus += $3; } END { print ncpus; }' $TMP_FILE`
rm -f $TMP_FILE
unset TMP_FILE

read INF_CPUSET < /proc/self/cpuset
if [ "$INF_CPUSET" != "/" ]; then
    INF_EXEC_TYPE="cpuset"
else
    if [ "$INF_MAX_NCPUS" -eq "$INF_NCPUS" ]; then
        INF_EXEC_TYPE="exclusive"
    else
        INF_EXEC_TYPE="raw"
    fi
fi

# setup OpenMPI ----------------------------------------------------------------

case "$INF_EXEC_TYPE" in
    cpuset|exclusive)
        export INF_OPENMPI1_SPEC="-report-bindings -bind-to-core"
        export INF_OPENMPI2_SPEC="-report-bindings -bind-to core"
        ;;
esac

export INF_MAX_NCPUS
export INF_CPUSET
export INF_EXEC_TYPE

# final reporting --------------------------------------------------------------

echo "INF_MAX_NCPUS     = $INF_MAX_NCPUS"
echo "INF_NCPUS         = $INF_NCPUS"
echo "INF_CPUSET        = $INF_CPUSET"
echo "INF_EXEC_TYPE     = $INF_EXEC_TYPE"
echo "INF_OPENMPI1_SPEC = $INF_OPENMPI1_SPEC"
echo "INF_OPENMPI2_SPEC = $INF_OPENMPI2_SPEC"





